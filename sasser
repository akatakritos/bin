#!/usr/bin/env ruby
#
# $ sasser
#   Finds all .scss files that have a matching file in css/ folder and compiles them
#
# $ sasser --watch
#   Finds all .scss files marked for compilation and watches them for changes,
#   compiling them on modification
#
# Search recursively for any *.scss file in a sass/ folder. If a corresponding output
# file is found in the adjacent css folder, yield that pair for compilation
#
# data/sass/style.scss
# data/sass/_mixins.scss
# data/css/style.css
#
# Given the above, only style.css will be processed because a corresponding style.css was
# found in the adjacent css folder.
#
require 'optparse'
require 'pathname'

class SassFile
  attr_reader :input, :output

  def initialize(input, output)
    @input  = relative_from_cwd(input)
    @output = relative_from_cwd(output)
  end

  private
    def relative_from_cwd(abs_path)
      Pathname.new(abs_path).relative_path_from(Pathname.new(Dir.pwd))
    end
end


class Sasser

  def initialize(dry_run = false)
    @dry_run = dry_run
  end

  def dry_run?
    @dry_run
  end

  def compile
    sass_files do |sass|
      puts "processing #{sass.input}"
      system "sass --style compressed #{sass.input} #{sass.output}"
    end
  end

  def watch
    cmd ="sass --style compressed --watch #{sass_files.map { |f| "#{f.input}:#{f.output}" }.join(' ') }"
    exec cmd
  end

  private

    def exec(cmd)
      puts cmd
      super(cmd) unless dry_run?
    end

    def system(cmd)
      if dry_run?
        puts cmd
      else
        super(cmd)
      end
    end

    def sass_files
      return to_enum(:sass_files) unless block_given?

      Dir['**/sass/*.scss'].each do |file|
        fullpath = File.expand_path(file)
        fulloutpath = File.expand_path(File.dirname(fullpath) + '/../css/' + File.basename(fullpath, ".scss") + ".css")
        yield SassFile.new(fullpath, fulloutpath) if File.exists?(fulloutpath) && valid?(file)
      end
    end

    def valid?(filename)
      !filename.match /node_modules/
    end


end


options = {
  :watch => false,
  :dryrun => false
};

OptionParser.new { |opts| 
  opts.banner =  "Usage: sasser [options]"

  opts.on("--watch", 'watch the sass files for changes') do
    options[:watch] = true
  end

  opts.on("--dry-run") do
    options[:dryrun] = true
  end
}.parse!


sasser = Sasser.new(options[:dryrun])
if options[:watch]
  sasser.watch
else
  sasser.compile
end
